Книга о монолитных приложениях, которые разрастаются до 200 моделей. И о том, как с этим жить.

# introduction
In this book you'll find techniques to scale large, monolithic Rails applications, learn how to use discipline, consistency and code organization to make your code grow more gently.
Not revolutionary patterns or new gems, but using tools you already know the smarter way
# New rules for Rails
# Beautiful controllers
Controllers are not fun (( 
Lots of code, not sure where to place code
Requires complex environment, hard to test.
Few ror guidelines.
So every controller is a bit different
## The case for consistent controller design
Need to have standards for controllers
Speed up dev, better team work
5. Normalizing user interactions
Normalize every user interaction to crud, even if doesn't look like
6. A better controller implementation
Short, dry, minimum glue code
7. Why have controllers at all?
Security (auth, auth)
Parse, whitelist parameters, loading and instantiating a model
Decide which view to render
No heavy lifting
Inherited resources and such gems: don't use for large apps - confusing configuration, too much magic
    IV Relearning ActiveRecord
    Activerecord is useful to validate data, form roundtrips, lifecycle callbacks
error handling and input validation
but it's easy to shoot yourself in the foot.
8. Understanding the ActiveRecord lifecycle
Ar requires your models to be written in a certain way
"Infinite protocol" of AR - "objects on rails"
Approaches:
- get rid of 'bad' methods generated by AR and leave only 'good' methods you can control (fig-leaf). but that's fighting AR
- alternate implementation: do stuff using validations and callbacks
So don't rely on custom model methods that are not callbacks.
Enforce the integrity of the validations and callbacks. But remember about update_attributes which doesn't fire callbacks.
Too many callbacks => look in 'Dealing with fat models'
9. The true API of ActiveRecord models
  using any API methods:
   1)  instantiate
   2) manipulate
   3) manipulating puts object in dirty state, not saved
   4) after validations: all changes are commited to db in a single transaction
Benefits: clear views, no need to learn objects custom api, impossible accidental misuse, possible to use standart controller design, many useful libs
  It's not exclusive to AR models, it's possible for unpersisted classes too.4. User interactions without a database
## 4. User interactions without a database
    There are many ui interactions that don't need changes in db: sign in form, search form, payment form.
Useful AR features for such forms: validations and form roundtrips, attributes setterst to cast, translations, transactional-style submissions.
10. Writing a better sign in form
SignInForm < PlainModel
(link to code, if possible)
PlainModel is a class that makes POROs feel a lot like ActiveRecord.
PlainModel is a wrapper around ActiveModel
Virtus?
SignInForm has the same lifecycle of AR model:
- attributes set from params
- object is asked to validate its attributes
- if the object can be saved, some action is performed
11. Building PlainModel
Custom wrapper around Active model
Gem ActiveType from the book authors
12. Refactoring controllers from hell
Hell - long, lots of logic
Refactor with a class inheriting from ActiveType - clean view, clean controller
Form object with callbacks - move the code from the controller.
Unit tests controller are easier
Any controller:
- instantiate an object
- assign attributes
- try to save
- render a view or redirect
# Creating a system for growth
# Dealing with fat models
Problems: afraid of calling unneeded callback, too much callbacks and validations, different UI requires different support code from your model
13. Why models grow fat
More and more purposes, lots of use cases
Different forms need different validations, fear of unneeded callbacks triggering, hard to test because of side-effects
14. The case of the missing classes
Code never goes away, you'll need to put it into a place or it'll infest an existing class
15. Getting into a habit of organizing
Instead of looking for existing AR class first look for new classes
VIII A home for interaction-specific code
Reduce fat model to  slim core model. Create multiple interaction-specific form models.
Model: minimum of validations, associations, universal methods.
Not: validations for specific views, virtual attributes, callbacks for particular case, auth, helpers for views and rendering
16. A modest approach to form models
Problems with gems for form objects, presenters, etc
Vanilla inheritance for form objects
Use::Assign up < User
17. More convenience for form models
Tweaks from ActiveType + inheritance
User::AsSignUp  < ActiveType:: Record [User]
IX Extracting service objects
In a fat model there is a lot of code that doesn't need to be tied to AR. Such code should be extracted into poros. Slim down: walk through the code and find what code can be extracted into service objects.
18. Example
Move Note#search and connected methods to Note::Search
Aggressively look for opportunities to extract into service objects
19. Did we just move code around?
Yes, but we move from large monolithic blocks to multiple components
X Organizing large codebases with namespaces
Namespace models in sub-folders, it makes much easier to browse.
app/models/invoice.rb
app/models/invoice/item.rb (Invoice::Item, belongs_to :invoice)
app/models/invoice/export.rb
...
20. Real-world example
21. Use the same structure everywhere
Make sure namespacing is also adopted by all the other places that are organized by model.
(helpers, controllers, views)
app/views/projects/index.html.erb
app/views/projects/reports/index.html.erb
Have a good default of organizing files
XI Taming stylesheets
css files can spiral out of control easily:
- afraid that change will break some screens
- simple p or label already inherits millions of styles
- you often have to use "!important"
22. How CSS grows out of control
Maintainable css is hard.
23. An API for your stylesheets
BEM (Block, Element, Modifier) - a set of rules
It's like spaghetti vs OOP
#### Blocks
BEM stylesheets consist of a simple list of blocks:
e.g. nav bar, article, row of buttons.
You can think of them as classes.
#### Elements
Blocks comprise elements.
Elements can only exist as the child of one specific block, their name is prefixed by block name.
An element can't exist without a block. They are like methods of the class (block).
The list of selectors is always flat, avoid nesting.
.article{}
.article__title{}
.article__text {}
#### Modifiers
E.g. we need a block that behaves 90% like another block.
Modifiers are the optional parameters of the blocks and elements.
Implemented as conjunctive selectors on an existing block or modifier
Overshadow existing style from the same block.
.button.is_primary { .. }
Modifiers are not prefixed with the name of their block.
Choose names like is_small or has_children
Block modifiers can also modify elements as they are within the same block.
.article.is_summary . article__title {}
24. The BEM prime directive
A block must never influence the style of other blocks
- no inheritance of unwanted styles
- no fear of breaking styles
- easy to reuse
Instead of:
.article{}
.Sidebar.Article{}
Do:
.sidebar{}
 .sidebar__article{}
Or:
.Article{}
. Article.is_summary{}
.Sidebar{}
Escape from CSS hell by isolating blocks.
25. Full BEM layout example
Do be wary of God blocks that grow too large
26. Organizing stylesheets
One file for each block
27. BEM anti-patterns
- badly named elements
- giant god blocks
- blocks for each screen
- violation of prime directive
You are creating API for your stylesheets
28. Living style guides
Use gems like hologram to generate living docs.
29. Pragmatic BEM
There are situations when you can slightly deviate from bem dogma, e.g.compound structures like tables.
When to be pragmatic:
- compound elements like tables, I'll
...
If you are unsure, be strict

# Building applications to last
# On following fashions
30. Before/after code comparisons
Compare before and after code when you are testing a new fashion/style
+ is the code easier?
- amount of code, number of files, coupling- changed?
- are there new issues?
- requires new library? Worth it?
Decide if using new pattern works for you?
31. Understanding trade-offs
New patterns are incremental improvements, not silver bullets.
Scan them for trade-offs
32. The value of consistency
Don't adapt every new fashion, cause your app will be a patchwork of different styles.
Consistent code style is the priority.
    XIV Surviving the upgrade pace of Rails
33. Gems increase the cost of upgrades
So think before using a new gem
34. Upgrades are when you pay for monkey patches
35. Don’t live on the bleeding edge
 XV Owning your stack
Decide whether to use specific gem:
- is the code well-groomed or messy
- tests?
- active development?
- are you ready to maintain in case?
- functionality significant to accept the cost of integration and maintenance or is it easier to implement yourself?
36. Accepting storage services into your stack 
...
37. Maxing out your current toolbox
Go with a simple solution until your load or data volume justify the changeto easily switch later hide service access behind a simple API.
TODO - example
XVI The value of tests
Learning to test is the most important skill.
Benefits: no bugs, not scary releases, refactor without fear, ability to work on 1 part of the app without knowing the rest.
But you need time to write tests and maintain them
38. Choosing test types effectively
Most value: unit tests and full-stack integration tests (cucumber)
- cover as much as possible with integration tests
- every UI screen should be kissed by at least one integration test
- need to test many edge cases => unit tests
39. How many tests are too many
The dark house rule
40. When to repeat yourself in tests - and when not to
Some repetition in tests is ok, they shouldn't be too clever.
41. Better design guided by tests
"Use" the class in unit test before it (the class) even exists, test-driven design, improves quality.
42. Getting started with tests in legacy applications
Write the full.integration tests, that walks along the "happy" path that is most central to your app.
Whenever you make a change, create another test.
You don't need full coverage to benefit from tests.
43. Overcoming resistance to testing in your team
Usable test suite, 1 command to run.
No code should be committed without green tests.

